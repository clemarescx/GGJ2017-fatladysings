// Decompiled with JetBrains decompiler
// Type: Medallion.Rand
// Assembly: MedallionRandom, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: CCEDA9D8-4141-4F26-956E-20B095287108
// Assembly location: /Users/Thomas/MEGA/Unity/GlobalGameJam17/GlobalGameJam/packages/MedallionRandom.1.0.1/lib/net35/MedallionRandom.dll

using System;
using System.Collections.Generic;
using System.Linq;
using System.Security.Cryptography;
using System.Threading;

namespace Medallion
{
    /// <summary>
    /// Contains helpers and extensions for working with random number generators
    /// </summary>
    public static class Rand
    {
        /// <summary>
        /// Returns a thread-safe <see cref="T:System.Random" /> instance which can be used
        /// for static random calls
        /// </summary>
        public static Random Current
        {
            get
            {
                return (Random) Rand.SingletonRandom.Instance;
            }
        }

        /// <summary>Returns a random boolean value</summary>
        public static bool NextBoolean(this Random random)
        {
            if (random == null)
                throw new ArgumentNullException("random");
            return (uint) random.NextBits(1) > 0U;
        }

        /// <summary>Returns a random 32-bit integer</summary>
        public static int NextInt32(this Random random)
        {
            if (random == null)
                throw new ArgumentNullException("random");
            return random.NextBits(32);
        }

        /// <summary>Returns a random 64-bit integer</summary>
        public static long NextInt64(this Random random)
        {
            if (random == null)
                throw new ArgumentNullException("random");
            Rand.NextBitsRandom nextBitsRandom = random as Rand.NextBitsRandom;
            if (nextBitsRandom != null)
                return ((long) nextBitsRandom.NextBits(32) << 32) + (long) nextBitsRandom.NextBits(32);
            return ((long) random.Next30OrFewerBits(22) << 42) + ((long) random.Next30OrFewerBits(21) << 21) + (long) random.Next30OrFewerBits(21);
        }

        /// <summary>
        /// Returns a random <see cref="T:System.Single" /> value in [0, 1)
        /// </summary>
        public static float NextSingle(this Random random)
        {
            if (random == null)
                throw new ArgumentNullException("random");
            return (float) random.NextBits(24) / 1.677722E+07f;
        }

        /// <summary>
        /// Returns the sequence of values that would be generated by repeated
        /// calls to <see cref="M:System.Random.NextDouble" />
        /// </summary>
        public static IEnumerable<double> NextDoubles(this Random random)
        {
            if (random == null)
                throw new ArgumentNullException("random");
            return Rand.NextDoublesIterator(random);
        }

        private static IEnumerable<double> NextDoublesIterator(Random random)
        {
            while (true)
                yield return random.NextDouble();
        }

        private static int NextBits(this Random random, int bits)
        {
            Rand.NextBitsRandom nextBitsRandom = random as Rand.NextBitsRandom;
            if (nextBitsRandom != null)
                return nextBitsRandom.NextBits(bits);
            if (bits <= 30)
                return random.Next30OrFewerBits(bits);
            return random.Next30OrFewerBits(bits - 16) << 16 | random.Next30OrFewerBits(16);
        }

        private static int Next30OrFewerBits(this Random random, int bits)
        {
            int num1 = 1 << bits;
            int num2 = int.MaxValue - (int.MaxValue & num1 - 1);
            int num3;
            do
            {
                num3 = random.Next();
            }
            while (num3 >= num2);
            return num3 & num1 - 1;
        }

        /// <summary>
        /// Returns true with probability <paramref name="probability" />
        /// </summary>
        public static bool NextBoolean(this Random random, double probability)
        {
            if (random == null)
                throw new ArgumentNullException("random");
            if (probability == 0.0)
                return false;
            if (probability == 1.0)
                return true;
            if (probability < 0.0 || probability > 1.0)
                throw new ArgumentOutOfRangeException("probability", string.Format("{0} must be in [0, 1]. Found {1}", (object) "probability", (object) probability));
            if (double.IsNaN(probability))
                throw new ArgumentException("must not be NaN", "probability");
            return random.NextDouble() < probability;
        }

        /// <summary>
        /// Returns the sequence of bytes that would be returned by repeated calls
        /// to <see cref="M:System.Random.NextBytes(System.Byte[])" />
        /// </summary>
        public static IEnumerable<byte> NextBytes(this Random random)
        {
            if (random == null)
                throw new ArgumentNullException("random");
            return Rand.NextBytesIterator(random);
        }

        private static IEnumerable<byte> NextBytesIterator(Random random)
        {
            byte[] buffer = new byte[256];
            label_1:
            random.NextBytes(buffer);
            for (int i = 0; i < buffer.Length; ++i)
                yield return buffer[i];
            goto label_1;
        }

        /// <summary>
        /// Returns <paramref name="source" /> randomly shuffled using
        /// <paramref name="random" /> or else <see cref="P:Medallion.Rand.Current" />.
        ///
        /// This method performs a lazy "streaming" shuffle: when the first
        /// element of the returned <see cref="T:System.Collections.Generic.IEnumerable`1" /> is requested, the
        /// entire <paramref name="source" /> sequence is enumerated. The <paramref name="random" />
        /// is then used lazily to shuffle the next element into place as the result
        /// sequence is enumerated
        /// </summary>
        public static IEnumerable<T> Shuffled<T>(this IEnumerable<T> source, Random random = null)
        {
            if (source == null)
                throw new ArgumentNullException("source");
            return Rand.ShuffledIterator<T>(source, random ?? (Random) Rand.SingletonRandom.Instance);
        }

        private static IEnumerable<T> ShuffledIterator<T>(IEnumerable<T> source, Random random)
        {
            List<T> list = source.ToList<T>();
            if (list.Count != 0)
            {
                for (int i = 0; i < list.Count - 1; ++i)
                {
                    int index = random.Next(i, list.Count);
                    T obj = list[index];
                    list[index] = list[i];
                    yield return obj;
                }
                yield return list[list.Count - 1];
            }
        }

        /// <summary>
        /// Shuffles the given <paramref name="list" /> using <paramref name="random" />
        /// if provided or else <see cref="P:Medallion.Rand.Current" />
        /// </summary>
        public static void Shuffle<T>(this IList<T> list, Random random = null)
        {
            if (list == null)
                throw new ArgumentNullException("list");
            Random random1 = random ?? (Random) Rand.ThreadLocalRandom.Current;
            for (int minValue = 0; minValue < list.Count - 1; ++minValue)
            {
                int index = random1.Next(minValue, list.Count);
                T obj = list[index];
                list[index] = list[minValue];
                list[minValue] = obj;
            }
        }

        /// <summary>
        /// Returns a normally-distributed double value with mean 0 and standard deviation 1
        /// </summary>
        public static double NextGaussian(this Random random)
        {
            if (random == null)
                throw new ArgumentNullException("random");
            Rand.INextGaussianRandom nextGaussianRandom = random as Rand.INextGaussianRandom;
            if (nextGaussianRandom != null)
                return nextGaussianRandom.NextGaussian();
            double num1;
            double num2;
            random.NextTwoGaussians(out num1, out num2);
            return num1;
        }

        private static void NextTwoGaussians(this Random random, out double value1, out double value2)
        {
            double num1;
            double num2;
            double d;
            do
            {
                num1 = 2.0 * random.NextDouble() - 1.0;
                num2 = 2.0 * random.NextDouble() - 1.0;
                d = num1 * num1 + num2 * num2;
            }
            while (d >= 1.0 || d == 0.0);
            double num3 = Math.Sqrt(-2.0 * Math.Log(d) / d);
            value1 = num1 * num3;
            value2 = num2 * num3;
        }

        /// <summary>
        /// Returns a random double value uniformly in [0, <paramref name="max" />). The underlying randomness is
        /// provided by <see cref="M:System.Random.NextDouble" />, which may be unsuitable for very large ranges
        /// </summary>
        public static double NextDouble(this Random random, double max)
        {
            if (random == null)
                throw new ArgumentNullException("random");
            if (max < 0.0)
                throw new ArgumentOutOfRangeException("max", (object) max, "must be non-negative");
            if (double.IsNaN(max) || double.IsInfinity(max))
                throw new ArgumentException("must not be infinity or NaN", "max");
            if (max == 0.0)
                return 0.0;
            return max * random.NextDouble();
        }

        /// <summary>
        /// Returns a random double value uniformly in [<paramref name="min" />, <paramref name="max" />). The
        /// underlying randomness is provided by <see cref="M:System.Random.NextDouble" />, which may be unsuitable for
        /// very large ranges
        /// </summary>
        public static double NextDouble(this Random random, double min, double max)
        {
            if (random == null)
                throw new ArgumentNullException("random");
            double d = max - min;
            if (double.IsNaN(d) || double.IsInfinity(d))
            {
                if (double.IsNaN(min))
                    throw new ArgumentException("must not be NaN", "min");
                if (double.IsNaN(max))
                    throw new ArgumentException("must not be NaN", "max");
                if (double.IsInfinity(min))
                    throw new ArgumentOutOfRangeException("min", (object) min, "must not be infinite");
                if (double.IsInfinity(max))
                    throw new ArgumentOutOfRangeException("max", (object) max, "must not be infinite");
                throw new ArgumentOutOfRangeException("max", (object) max, string.Format("difference between {0} and {1} is too large to be represented by {2}", (object) min, (object) max, (object) typeof (double)));
            }
            if (d < 0.0)
                throw new ArgumentOutOfRangeException("max", (object) max, "must be greater than or equal to min");
            if (d == 0.0)
                return min;
            return min + d * random.NextDouble();
        }

        /// <summary>Returns a double value in [0, 1)</summary>
        public static double NextDouble()
        {
            return Rand.ThreadLocalRandom.Current.NextDouble();
        }

        /// <summary>
        /// Returns an int value in [<paramref name="minValue" />, <paramref name="maxValue" />)
        /// </summary>
        public static int Next(int minValue, int maxValue)
        {
            return Rand.ThreadLocalRandom.Current.Next(minValue, maxValue);
        }

        private static int HashCombine(int hash1, int hash2)
        {
            return (hash1 << 5) + hash1 ^ hash2;
        }

        /// <summary>
        /// Comparable to <code>new Random()</code>, but seeds the <see cref="T:System.Random" /> with
        /// a time-dependent value that will still vary greatly across calls to <see cref="M:Medallion.Rand.Create" />.
        /// This avoids the problem of many <see cref="T:System.Random" />s created close together being seeded
        /// with the same value
        /// </summary>
        public static Random Create()
        {
            return new Random(Rand.HashCombine(Environment.TickCount, Rand.ThreadLocalRandom.Current.Next()));
        }

        /// <summary>
        /// Creates a <see cref="T:System.Random" /> that uses the same algorithm as the JRE. The <see cref="T:System.Random" />
        /// is seeded with a time-dependent value which will vary greatly even across close-together calls to
        /// <see cref="M:Medallion.Rand.CreateJavaRandom" />
        /// </summary>
        public static Random CreateJavaRandom()
        {
            return Rand.CreateJavaRandom(Rand.ThreadLocalRandom.Current.NextInt64() ^ (long) Environment.TickCount);
        }

        /// <summary>
        /// Creates a <see cref="T:System.Random" /> which replicates the same random sequence as is produced by
        /// the standard random number generator in the JRE using the same <paramref name="seed" />
        /// </summary>
        public static Random CreateJavaRandom(long seed)
        {
            return (Random) new Rand.JavaRandom(seed);
        }

        /// <summary>
        /// Returns a <see cref="T:System.Random" /> instance which uses the given <paramref name="randomNumberGenerator" />
        /// as a source of randomness
        /// </summary>
        public static Random AsRandom(this RandomNumberGenerator randomNumberGenerator)
        {
            if (randomNumberGenerator == null)
                throw new ArgumentNullException("randomNumberGenerator");
            return (Random) new Rand.RandomNumberGeneratorRandom(randomNumberGenerator);
        }

        private interface INextGaussianRandom
        {
            double NextGaussian();
        }

        private sealed class SingletonRandom : Random, Rand.INextGaussianRandom
        {
            public static readonly Rand.SingletonRandom Instance = new Rand.SingletonRandom();

            private SingletonRandom()
                : base(0)
            {
            }

            public override int Next()
            {
                return Rand.ThreadLocalRandom.Current.Next();
            }

            public override int Next(int maxValue)
            {
                return Rand.ThreadLocalRandom.Current.Next(maxValue);
            }

            public override int Next(int minValue, int maxValue)
            {
                return Rand.ThreadLocalRandom.Current.Next(minValue, maxValue);
            }

            public override void NextBytes(byte[] buffer)
            {
                Rand.ThreadLocalRandom.Current.NextBytes(buffer);
            }

            public override double NextDouble()
            {
                return Rand.ThreadLocalRandom.Current.NextDouble();
            }

            protected override double Sample()
            {
                return Rand.ThreadLocalRandom.Current.NextDouble();
            }

            double Rand.INextGaussianRandom.NextGaussian()
            {
                return Rand.ThreadLocalRandom.Current.NextGaussian();
            }
        }

        private sealed class ThreadLocalRandom : Random, Rand.INextGaussianRandom
        {
            private static readonly DateTime SeedTime = DateTime.UtcNow;
            [ThreadStatic]
            private static Rand.ThreadLocalRandom currentInstance;
            private double? nextNextGaussian;

            public static Rand.ThreadLocalRandom Current
            {
                get
                {
                    return Rand.ThreadLocalRandom.currentInstance ?? (Rand.ThreadLocalRandom.currentInstance = new Rand.ThreadLocalRandom());
                }
            }

            private ThreadLocalRandom()
                : base(Rand.HashCombine(Rand.HashCombine(Rand.ThreadLocalRandom.SeedTime.GetHashCode(), Thread.CurrentThread.ManagedThreadId), Environment.TickCount))
            {
            }

            public double NextGaussian()
            {
                if (this.nextNextGaussian.HasValue)
                {
                    double num = this.nextNextGaussian.Value;
                    this.nextNextGaussian = new double?();
                    return num;
                }
                double num1;
                double num2;
                this.NextTwoGaussians(out num1, out num2);
                this.nextNextGaussian = new double?(num2);
                return num1;
            }
        }

        private abstract class NextBitsRandom : Random, Rand.INextGaussianRandom
        {
            private double? nextNextGaussian;

            protected NextBitsRandom(int seed)
                : base(seed)
            {
            }

            internal abstract int NextBits(int bits);

            public override sealed int Next()
            {
                return this.Next(int.MaxValue);
            }

            public override sealed int Next(int maxValue)
            {
                if (maxValue == 0)
                    return 0;
                if (maxValue <= 0)
                    throw new ArgumentOutOfRangeException("maxValue", string.Format("{0} must be positive.", (object) "maxValue"));
                if ((maxValue & -maxValue) == maxValue)
                    return (int) ((long) maxValue * (long) this.NextBits(31) >> 31);
                int num1;
                int num2;
                do
                {
                    num1 = this.NextBits(31);
                    num2 = num1 % maxValue;
                }
                while (num1 - num2 + (maxValue - 1) < 0);
                return num2;
            }

            public override sealed int Next(int minValue, int maxValue)
            {
                if (minValue == maxValue)
                    return minValue;
                if (minValue > maxValue)
                    throw new ArgumentOutOfRangeException("minValue", string.Format("{0} ({1}) must not be > {2} ({3})", (object) "minValue", (object) minValue, (object) "maxValue", (object) maxValue));
                long num1 = (long) maxValue - (long) minValue;
                if (num1 <= (long) int.MaxValue)
                    return minValue + this.Next((int) num1);
                long num2 = this.NextInt64();
                long num3 = num1 - 1L;
                long num4;
                if ((num1 & num3) == 0L)
                {
                    num4 = num2 & num3;
                }
                else
                {
                    long num5 = (long) ((ulong) num2 >> 1);
                    while (num5 + num3 - (num4 = num5 % num1) < 0L)
                        num5 = (long) ((ulong) this.NextInt64() >> 1);
                }
                return checked ((int) (num4 + (long) minValue));
            }

            public override void NextBytes(byte[] buffer)
            {
                if (buffer == null)
                    throw new ArgumentNullException("buffer");
                int num1 = 0;
                while (num1 < buffer.Length)
                {
                    int num2 = this.NextBits(32);
                    int num3 = Math.Min(buffer.Length - num1, 4);
                    while (num3-- > 0)
                    {
                        buffer[num1++] = (byte) num2;
                        num2 >>= 8;
                    }
                }
            }

            public override sealed double NextDouble()
            {
                return this.Sample();
            }

            protected override sealed double Sample()
            {
                return (double) (((long) this.NextBits(26) << 27) + (long) this.NextBits(27)) / 9.00719925474099E+15;
            }

            double Rand.INextGaussianRandom.NextGaussian()
            {
                if (this.nextNextGaussian.HasValue)
                {
                    double num = this.nextNextGaussian.Value;
                    this.nextNextGaussian = new double?();
                    return num;
                }
                double num1;
                double num2;
                this.NextTwoGaussians(out num1, out num2);
                this.nextNextGaussian = new double?(num2);
                return num1;
            }
        }

        private sealed class JavaRandom : Rand.NextBitsRandom
        {
            private long seed;

            public JavaRandom(long seed)
                : base((int) seed)
            {
                this.seed = (seed ^ 25214903917L) & 281474976710655L;
            }

            internal override int NextBits(int bits)
            {
                this.seed = this.seed * 25214903917L + 11L & 281474976710655L;
                return (int) ((ulong) this.seed >> 48 - bits);
            }
        }

        private sealed class RandomNumberGeneratorRandom : Rand.NextBitsRandom
        {
            private readonly byte[] buffer = new byte[512];
            private int nextByteIndex = 512;
            private const int BufferLength = 512;
            private readonly RandomNumberGenerator rand;

            internal RandomNumberGeneratorRandom(RandomNumberGenerator randomNumberGenerator)
                : base(0)
            {
                this.rand = randomNumberGenerator;
            }

            internal override int NextBits(int bits)
            {
                uint num1 = 0;
                int num2 = 0;
                do
                {
                    if (this.nextByteIndex == 512)
                    {
                        this.rand.GetBytes(this.buffer);
                        this.nextByteIndex = 0;
                    }
                    int num3 = (int) num1;
                    byte[] buffer = this.buffer;
                    int nextByteIndex = this.nextByteIndex;
                    this.nextByteIndex = checked (nextByteIndex + 1);
                    int index = nextByteIndex;
                    int num4 = (int) buffer[index] << num2;
                    num1 = checked (unchecked ((uint) num3) + unchecked ((uint) num4));
                    num2 += 8;
                }
                while (num2 < bits);
                return (int) (num1 >> num2 - bits);
            }

            public override void NextBytes(byte[] buffer)
            {
                if (buffer == null)
                    throw new ArgumentNullException("buffer");
                if (buffer.Length <= 512 - this.nextByteIndex)
                {
                    for (int nextByteIndex = this.nextByteIndex; nextByteIndex < buffer.Length; ++nextByteIndex)
                        buffer[nextByteIndex] = this.buffer[nextByteIndex];
                    this.nextByteIndex = this.nextByteIndex + buffer.Length;
                }
                else
                    this.rand.GetBytes(buffer);
            }
        }
    }
}
